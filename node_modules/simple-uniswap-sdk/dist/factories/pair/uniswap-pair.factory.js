"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniswapPairFactory = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const rxjs_1 = require("rxjs");
const constants_1 = require("../../common/constants");
const error_codes_1 = require("../../common/errors/error-codes");
const uniswap_error_1 = require("../../common/errors/uniswap-error");
const hexlify_1 = require("../../common/utils/hexlify");
const parse_ether_1 = require("../../common/utils/parse-ether");
const to_ethers_big_number_1 = require("../../common/utils/to-ethers-big-number");
const trade_path_1 = require("../../common/utils/trade-path");
const trade_path_2 = require("../../enums/trade-path");
const uniswap_version_1 = require("../../enums/uniswap-version");
const uniswap_contract_context_v2_1 = require("../../uniswap-contract-context/uniswap-contract-context-v2");
const uniswap_contract_context_v3_1 = require("../../uniswap-contract-context/uniswap-contract-context-v3");
const uniswap_router_factory_1 = require("../router/uniswap-router.factory");
const uniswap_router_contract_factory_v2_1 = require("../router/v2/uniswap-router-contract.factory.v2");
const fee_amount_v3_1 = require("../router/v3/enums/fee-amount-v3");
const uniswap_router_contract_factory_v3_1 = require("../router/v3/uniswap-router-contract.factory.v3");
const token_factory_1 = require("../token/token.factory");
class UniswapPairFactory {
    constructor(_uniswapPairFactoryContext) {
        this._uniswapPairFactoryContext = _uniswapPairFactoryContext;
        this._fromTokenFactory = new token_factory_1.TokenFactory(this._uniswapPairFactoryContext.fromToken.contractAddress, this._uniswapPairFactoryContext.ethersProvider);
        this._toTokenFactory = new token_factory_1.TokenFactory(this._uniswapPairFactoryContext.toToken.contractAddress, this._uniswapPairFactoryContext.ethersProvider);
        this._uniswapRouterContractFactoryV2 = new uniswap_router_contract_factory_v2_1.UniswapRouterContractFactoryV2(this._uniswapPairFactoryContext.ethersProvider);
        this._uniswapRouterContractFactoryV3 = new uniswap_router_contract_factory_v3_1.UniswapRouterContractFactoryV3(this._uniswapPairFactoryContext.ethersProvider);
        this._uniswapRouterFactory = new uniswap_router_factory_1.UniswapRouterFactory(this._uniswapPairFactoryContext.fromToken, this._uniswapPairFactoryContext.toToken, this._uniswapPairFactoryContext.settings.disableMultihops, this._uniswapPairFactoryContext.settings.uniswapVersions, this._uniswapPairFactoryContext.ethersProvider);
        this._quoteChanged$ = new rxjs_1.Subject();
    }
    /**
     * The to token
     */
    get toToken() {
        return this._uniswapPairFactoryContext.toToken;
    }
    /**
     * The from token
     */
    get fromToken() {
        return this._uniswapPairFactoryContext.fromToken;
    }
    /**
     * Get the to token balance
     */
    getFromTokenBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tradePath() === trade_path_2.TradePath.ethToErc20) {
                const ethBalanceContext = yield this.getEthBalance();
                return ethBalanceContext.toFixed();
            }
            const erc20BalanceContext = yield this._fromTokenFactory.balanceOf(this._uniswapPairFactoryContext.ethereumAddress);
            return new bignumber_js_1.default(erc20BalanceContext)
                .shiftedBy(this.fromToken.decimals * -1)
                .toFixed();
        });
    }
    /**
     * Get the to token balance
     */
    getToTokenBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tradePath() === trade_path_2.TradePath.erc20ToEth) {
                const ethBalanceContext = yield this.getEthBalance();
                return ethBalanceContext.toFixed();
            }
            const erc20BalanceContext = yield this._toTokenFactory.balanceOf(this._uniswapPairFactoryContext.ethereumAddress);
            return new bignumber_js_1.default(erc20BalanceContext)
                .shiftedBy(this.toToken.decimals * -1)
                .toFixed();
        });
    }
    /**
     * Execute the trade path
     * @param amount The amount
     */
    executeTradePath(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (this.tradePath()) {
                case trade_path_2.TradePath.erc20ToEth:
                    return yield this.getTokenTradeAmountErc20ToEth(amount);
                case trade_path_2.TradePath.ethToErc20:
                    return yield this.getTokenTradeAmountEthToErc20(amount);
                case trade_path_2.TradePath.erc20ToErc20:
                    return yield this.getTokenTradeAmountErc20ToErc20(amount);
                default:
                    throw new uniswap_error_1.UniswapError(`${this.tradePath()} is not defined`, error_codes_1.ErrorCodes.tradePathIsNotSupported);
            }
        });
    }
    /**
     * Destroy the trade instance watchers + subscriptions
     */
    destroy() {
        for (let i = 0; i < this._quoteChanged$.observers.length; i++) {
            this._quoteChanged$.observers[i].complete();
        }
        if (this._quoteChangeTimeout) {
            clearTimeout(this._quoteChangeTimeout);
        }
    }
    /**
     * Generate trade - this will return amount but you still need to send the transaction
     * if you want it to be executed on the blockchain
     * @amount The amount you want to swap, this is the FROM token amount.
     */
    trade(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            this.destroy();
            const tradeContext = yield this.executeTradePath(new bignumber_js_1.default(amount));
            this.watchTradePrice(tradeContext);
            return tradeContext;
        });
    }
    /**
     * Route getter
     */
    get _routes() {
        return this._uniswapRouterFactory;
    }
    /**
     * Find the best route rate out of all the route quotes
     * @param amountToTrade The amount to trade
     */
    findBestRoute(amountToTrade) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._routes.findBestRoute(new bignumber_js_1.default(amountToTrade));
        });
    }
    /**
     * Find the best route rate out of all the route quotes
     * @param amountToTrade The amount to trade
     */
    findAllPossibleRoutesWithQuote(amountToTrade) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._routes.getAllPossibleRoutesWithQuotes(new bignumber_js_1.default(amountToTrade));
        });
    }
    /**
     * Find all possible routes
     */
    findAllPossibleRoutes() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._routes.getAllPossibleRoutes();
        });
    }
    /**
     * Has got enough allowance to do the trade
     * @param uniswapVersion The uniswap version
     * @param amount The amount you want to swap
     */
    hasGotEnoughAllowance(uniswapVersion, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tradePath() === trade_path_2.TradePath.ethToErc20) {
                return true;
            }
            const allowance = yield this.allowance(uniswapVersion);
            return this._hasGotEnoughAllowance(amount, allowance);
        });
    }
    /**
     * Has got enough allowance to do the trade
     * @param amount The amount you want to swap
     */
    _hasGotEnoughAllowance(amount, allowance) {
        if (this.tradePath() === trade_path_2.TradePath.ethToErc20) {
            return true;
        }
        const bigNumberAllowance = new bignumber_js_1.default(allowance).shiftedBy(this.fromToken.decimals * -1);
        if (new bignumber_js_1.default(amount).isGreaterThan(bigNumberAllowance)) {
            return false;
        }
        return true;
    }
    /**
     * Has got enough balance to do the trade (erc20 check only)
     * @param amount The amount you want to swap
     */
    hasGotEnoughBalanceErc20(amount, balance) {
        const bigNumberBalance = new bignumber_js_1.default(balance).shiftedBy(this.fromToken.decimals * -1);
        if (new bignumber_js_1.default(amount).isGreaterThan(bigNumberBalance)) {
            return {
                hasEnough: false,
                balance: bigNumberBalance.toFixed(),
            };
        }
        return {
            hasEnough: true,
            balance: bigNumberBalance.toFixed(),
        };
    }
    /**
     * Has got enough balance to do the trade (eth check only)
     * @param amount The amount you want to swap
     */
    hasGotEnoughBalanceEth(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const balance = yield this.getEthBalance();
            if (new bignumber_js_1.default(amount).isGreaterThan(balance)) {
                return {
                    hasEnough: false,
                    balance: balance.toFixed(),
                };
            }
            return {
                hasEnough: true,
                balance: balance.toFixed(),
            };
        });
    }
    /**
     * Get eth balance
     */
    getEthBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            const balance = yield this._uniswapPairFactoryContext.ethersProvider.balanceOf(this._uniswapPairFactoryContext.ethereumAddress);
            return new bignumber_js_1.default(balance).shiftedBy(constants_1.Constants.ETH_MAX_DECIMALS * -1);
        });
    }
    /**
     * Get the allowance and balance for the from token (erc20 > blah) only
     * @param uniswapVersion The uniswap version
     */
    getAllowanceAndBalanceOfForFromToken(uniswapVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._fromTokenFactory.getAllowanceAndBalanceOf(uniswapVersion, this._uniswapPairFactoryContext.ethereumAddress);
        });
    }
    /**
     * Get the allowance and balance for to from token (eth > erc20) only
     * @param uniswapVersion The uniswap version
     */
    getAllowanceAndBalanceOfForToToken(uniswapVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._toTokenFactory.getAllowanceAndBalanceOf(uniswapVersion, this._uniswapPairFactoryContext.ethereumAddress);
        });
    }
    /**
     * Get the allowance for the amount which can be moved from the `fromToken`
     * on the users behalf. Only valid when the `fromToken` is a ERC20 token.
     * @param uniswapVersion The uniswap version
     */
    allowance(uniswapVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tradePath() === trade_path_2.TradePath.ethToErc20) {
                return '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';
            }
            const allowance = yield this._fromTokenFactory.allowance(uniswapVersion, this._uniswapPairFactoryContext.ethereumAddress);
            return allowance;
        });
    }
    /**
     * Generate the from token approve data max allowance to move the tokens.
     * This will return the data for you to send as a transaction
     * @param uniswapVersion The uniswap version
     */
    generateApproveMaxAllowanceData(uniswapVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tradePath() === trade_path_2.TradePath.ethToErc20) {
                throw new uniswap_error_1.UniswapError('You do not need to generate approve uniswap allowance when doing eth > erc20', error_codes_1.ErrorCodes.generateApproveMaxAllowanceDataNotAllowed);
            }
            const data = this._fromTokenFactory.generateApproveAllowanceData(uniswapVersion === uniswap_version_1.UniswapVersion.v2
                ? uniswap_contract_context_v2_1.UniswapContractContextV2.routerAddress
                : uniswap_contract_context_v3_1.UniswapContractContextV3.routerAddress, '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
            return {
                to: this.fromToken.contractAddress,
                from: this._uniswapPairFactoryContext.ethereumAddress,
                data,
                value: constants_1.Constants.EMPTY_HEX_STRING,
            };
        });
    }
    /**
     * Get the token trade amount for erc20 > eth
     * @param amount The amount
     */
    getTokenTradeAmountErc20ToEth(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.findBestPriceAndPathErc20ToEth(amount);
        });
    }
    /**
     * Gets how much token they will get for their trade minus all fees
     * @param ethAmount The eth amount
     */
    getTokenTradeAmountEthToErc20(ethAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.findBestPriceAndPathEthToErc20(ethAmount);
        });
    }
    /**
     * Get the token trade amount for erc20 > erc20
     * @param amount The amount
     */
    getTokenTradeAmountErc20ToErc20(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.findBestPriceAndPathErc20ToErc20(amount);
        });
    }
    /**
     * finds the best price and path for Erc20ToEth
     * @param amount the erc20Token amount being sent
     */
    findBestPriceAndPathErc20ToEth(erc20Amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const bestRouteQuotes = yield this._routes.findBestRoute(erc20Amount);
            const bestRouteQuote = bestRouteQuotes.bestRouteQuote;
            const convertQuoteWithSlippage = new bignumber_js_1.default(bestRouteQuote.expectedConvertQuote).minus(new bignumber_js_1.default(bestRouteQuote.expectedConvertQuote)
                .times(this._uniswapPairFactoryContext.settings.slippage)
                .toFixed(this.fromToken.decimals));
            const tradeExpires = this.generateTradeDeadlineUnixTime();
            const data = this.generateTradeDataErc20ToEth(erc20Amount, convertQuoteWithSlippage, bestRouteQuote, tradeExpires.toString());
            const allowanceAndBalanceOf = yield this.getAllowanceAndBalanceOfForFromToken(bestRouteQuote.uniswapVersion);
            const hasEnoughAllowance = this._hasGotEnoughAllowance(erc20Amount.toFixed(), allowanceAndBalanceOf.allowance);
            const tradeContext = {
                uniswapVersion: bestRouteQuote.uniswapVersion,
                baseConvertRequest: erc20Amount.toFixed(),
                minAmountConvertQuote: convertQuoteWithSlippage.toFixed(this.toToken.decimals),
                expectedConvertQuote: bestRouteQuote.expectedConvertQuote,
                liquidityProviderFee: erc20Amount
                    .times(bestRouteQuote.liquidityProviderFee)
                    .toFixed(this.fromToken.decimals),
                liquidityProviderFeePercent: bestRouteQuote.liquidityProviderFee,
                tradeExpires,
                routePathTokenMap: bestRouteQuote.routePathArrayTokenMap,
                routeText: bestRouteQuote.routeText,
                routePath: bestRouteQuote.routePathArray,
                hasEnoughAllowance,
                approvalTransaction: !hasEnoughAllowance
                    ? yield this.generateApproveMaxAllowanceData(bestRouteQuote.uniswapVersion)
                    : undefined,
                toToken: this.toToken,
                fromToken: this.fromToken,
                fromBalance: this.hasGotEnoughBalanceErc20(erc20Amount.toFixed(), allowanceAndBalanceOf.balanceOf),
                transaction: this.buildUpTransactionErc20(bestRouteQuote.uniswapVersion, data),
                allTriedRoutesQuotes: bestRouteQuotes.triedRoutesQuote,
                quoteChanged$: this._quoteChanged$,
                destroy: () => this.destroy(),
            };
            return tradeContext;
        });
    }
    /**
     * finds the best price and path for Erc20ToErc20
     * @param amount the erc20Token amount being sent
     */
    findBestPriceAndPathErc20ToErc20(erc20Amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const bestRouteQuotes = yield this._routes.findBestRoute(erc20Amount);
            const bestRouteQuote = bestRouteQuotes.bestRouteQuote;
            const convertQuoteWithSlippage = new bignumber_js_1.default(bestRouteQuote.expectedConvertQuote).minus(new bignumber_js_1.default(bestRouteQuote.expectedConvertQuote)
                .times(this._uniswapPairFactoryContext.settings.slippage)
                .toFixed(this.fromToken.decimals));
            const tradeExpires = this.generateTradeDeadlineUnixTime();
            const data = this.generateTradeDataErc20ToErc20(erc20Amount, convertQuoteWithSlippage, bestRouteQuote, tradeExpires.toString());
            const allowanceAndBalanceOf = yield this.getAllowanceAndBalanceOfForFromToken(bestRouteQuote.uniswapVersion);
            const hasEnoughAllowance = this._hasGotEnoughAllowance(erc20Amount.toFixed(), allowanceAndBalanceOf.allowance);
            const tradeContext = {
                uniswapVersion: bestRouteQuote.uniswapVersion,
                baseConvertRequest: erc20Amount.toFixed(),
                minAmountConvertQuote: convertQuoteWithSlippage.toFixed(this.toToken.decimals),
                expectedConvertQuote: bestRouteQuote.expectedConvertQuote,
                liquidityProviderFee: erc20Amount
                    .times(bestRouteQuote.liquidityProviderFee)
                    .toFixed(this.fromToken.decimals),
                liquidityProviderFeePercent: bestRouteQuote.liquidityProviderFee,
                tradeExpires,
                routePathTokenMap: bestRouteQuote.routePathArrayTokenMap,
                routeText: bestRouteQuote.routeText,
                routePath: bestRouteQuote.routePathArray,
                hasEnoughAllowance,
                approvalTransaction: !hasEnoughAllowance
                    ? yield this.generateApproveMaxAllowanceData(bestRouteQuote.uniswapVersion)
                    : undefined,
                toToken: this.toToken,
                fromToken: this.fromToken,
                fromBalance: this.hasGotEnoughBalanceErc20(erc20Amount.toFixed(), allowanceAndBalanceOf.balanceOf),
                transaction: this.buildUpTransactionErc20(bestRouteQuote.uniswapVersion, data),
                allTriedRoutesQuotes: bestRouteQuotes.triedRoutesQuote,
                quoteChanged$: this._quoteChanged$,
                destroy: () => this.destroy(),
            };
            return tradeContext;
        });
    }
    /**
     * Find the best price and route path to take (will round down the slippage)
     * @param ethAmount The eth amount
     */
    findBestPriceAndPathEthToErc20(ethAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            const bestRouteQuotes = yield this._routes.findBestRoute(ethAmount);
            const bestRouteQuote = bestRouteQuotes.bestRouteQuote;
            const convertQuoteWithSlippage = new bignumber_js_1.default(bestRouteQuote.expectedConvertQuote).minus(new bignumber_js_1.default(bestRouteQuote.expectedConvertQuote)
                .times(this._uniswapPairFactoryContext.settings.slippage)
                .toFixed(this.toToken.decimals));
            const tradeExpires = this.generateTradeDeadlineUnixTime();
            const data = this.generateTradeDataEthToErc20(ethAmount, convertQuoteWithSlippage, bestRouteQuote, tradeExpires.toString());
            const tradeContext = {
                uniswapVersion: bestRouteQuote.uniswapVersion,
                baseConvertRequest: ethAmount.toFixed(),
                minAmountConvertQuote: convertQuoteWithSlippage.toFixed(this.toToken.decimals),
                expectedConvertQuote: bestRouteQuote.expectedConvertQuote,
                liquidityProviderFee: ethAmount
                    .times(bestRouteQuote.liquidityProviderFee)
                    .toFixed(this.fromToken.decimals),
                liquidityProviderFeePercent: bestRouteQuote.liquidityProviderFee,
                tradeExpires,
                routePathTokenMap: bestRouteQuote.routePathArrayTokenMap,
                routeText: bestRouteQuote.routeText,
                routePath: bestRouteQuote.routePathArray,
                hasEnoughAllowance: true,
                toToken: this.toToken,
                fromToken: this.fromToken,
                fromBalance: yield this.hasGotEnoughBalanceEth(ethAmount.toFixed()),
                transaction: this.buildUpTransactionEth(bestRouteQuote.uniswapVersion, ethAmount, data),
                allTriedRoutesQuotes: bestRouteQuotes.triedRoutesQuote,
                quoteChanged$: this._quoteChanged$,
                destroy: () => this.destroy(),
            };
            return tradeContext;
        });
    }
    /**
     * Generate trade data eth > erc20
     * @param tokenAmount The token amount
     * @param routeQuote The route quote
     * @param deadline The deadline it expiries unix time
     */
    generateTradeDataEthToErc20(ethAmountIn, tokenAmount, routeQuote, deadline) {
        // uniswap adds extra digits on even if the token is say 8 digits long
        const convertedMinTokens = tokenAmount
            .shiftedBy(this.toToken.decimals)
            .decimalPlaces(0);
        switch (routeQuote.uniswapVersion) {
            case uniswap_version_1.UniswapVersion.v2:
                return this._uniswapRouterContractFactoryV2.swapExactETHForTokens(hexlify_1.hexlify(convertedMinTokens), routeQuote.routePathArray, this._uniswapPairFactoryContext.ethereumAddress, deadline);
            case uniswap_version_1.UniswapVersion.v3:
                return this.generateTradeDataForV3(parse_ether_1.parseEther(ethAmountIn), convertedMinTokens, routeQuote.routePathArray, deadline);
            default:
                throw new uniswap_error_1.UniswapError('Uniswap version not supported', error_codes_1.ErrorCodes.uniswapVersionNotSupported);
        }
    }
    /**
     * Generate trade amount erc20 > eth
     * @param tokenAmount The token amount
     * @param ethAmountOutMin The min eth in eth not wei this converts it
     * @param routeQuote The route quote
     * @param deadline The deadline it expiries unix time
     */
    generateTradeDataErc20ToEth(tokenAmount, ethAmountOutMin, routeQuote, deadline) {
        // uniswap adds extra digits on even if the token is say 8 digits long
        const amountIn = tokenAmount
            .shiftedBy(this.fromToken.decimals)
            .decimalPlaces(0);
        switch (routeQuote.uniswapVersion) {
            case uniswap_version_1.UniswapVersion.v2:
                return this._uniswapRouterContractFactoryV2.swapExactTokensForETH(hexlify_1.hexlify(amountIn), hexlify_1.hexlify(parse_ether_1.parseEther(ethAmountOutMin)), routeQuote.routePathArray, this._uniswapPairFactoryContext.ethereumAddress, deadline);
            case uniswap_version_1.UniswapVersion.v3:
                return this.generateTradeDataForV3(amountIn, parse_ether_1.parseEther(ethAmountOutMin), routeQuote.routePathArray, deadline);
            default:
                throw new uniswap_error_1.UniswapError('Uniswap version not supported', error_codes_1.ErrorCodes.uniswapVersionNotSupported);
        }
    }
    /**
     * Generate trade amount erc20 > erc20
     * @param tokenAmount The token amount
     * @param tokenAmountOut The min token amount out
     * @param routeQuote The route quote
     * @param deadline The deadline it expiries unix time
     */
    generateTradeDataErc20ToErc20(tokenAmount, tokenAmountMin, routeQuote, deadline) {
        // uniswap adds extra digits on even if the token is say 8 digits long
        const amountIn = tokenAmount
            .shiftedBy(this.fromToken.decimals)
            .decimalPlaces(0);
        const amountMin = tokenAmountMin
            .shiftedBy(this.toToken.decimals)
            .decimalPlaces(0);
        switch (routeQuote.uniswapVersion) {
            case uniswap_version_1.UniswapVersion.v2:
                return this._uniswapRouterContractFactoryV2.swapExactTokensForTokens(hexlify_1.hexlify(amountIn), hexlify_1.hexlify(amountMin), routeQuote.routePathArray, this._uniswapPairFactoryContext.ethereumAddress, deadline);
            case uniswap_version_1.UniswapVersion.v3:
                return this.generateTradeDataForV3(amountIn, amountMin, routeQuote.routePathArray, deadline);
            default:
                throw new uniswap_error_1.UniswapError('Uniswap version not supported', error_codes_1.ErrorCodes.uniswapVersionNotSupported);
        }
    }
    /**
     * Generate trade data for v3
     * @param tokenAmount The token amount
     * @param tokenAmountOut The min token amount out
     * @param routePathArray The route path array
     * @param deadline The deadline it expiries unix time
     */
    generateTradeDataForV3(tokenAmount, tokenAmountMin, routePathArray, deadline) {
        const params = {
            path: this._uniswapRouterFactory.encodeRoutePathV3(routePathArray, new Array(routePathArray.length - 1).fill(fee_amount_v3_1.FeeAmount.MEDIUM)),
            // recipient: outputIsWETH9 ? router.address : trader.address,
            recipient: this._uniswapPairFactoryContext.ethereumAddress,
            deadline,
            amountIn: hexlify_1.hexlify(tokenAmount),
            amountOutMinimum: hexlify_1.hexlify(tokenAmountMin),
        };
        return this._uniswapRouterContractFactoryV3.exactInput(params);
    }
    /**
     * Build up a transaction for erc20 from
     * @param data The data
     */
    buildUpTransactionErc20(uniswapVersion, data) {
        return {
            to: uniswapVersion === uniswap_version_1.UniswapVersion.v2
                ? uniswap_contract_context_v2_1.UniswapContractContextV2.routerAddress
                : uniswap_contract_context_v3_1.UniswapContractContextV3.routerAddress,
            from: this._uniswapPairFactoryContext.ethereumAddress,
            data,
            value: constants_1.Constants.EMPTY_HEX_STRING,
        };
    }
    /**
     * Build up a transaction for eth from
     * @param ethValue The eth value
     * @param data The data
     */
    buildUpTransactionEth(uniswapVersion, ethValue, data) {
        return {
            to: uniswapVersion === uniswap_version_1.UniswapVersion.v2
                ? uniswap_contract_context_v2_1.UniswapContractContextV2.routerAddress
                : uniswap_contract_context_v3_1.UniswapContractContextV3.routerAddress,
            from: this._uniswapPairFactoryContext.ethereumAddress,
            data,
            value: to_ethers_big_number_1.toEthersBigNumber(parse_ether_1.parseEther(ethValue)).toHexString(),
        };
    }
    /**
     * Get the trade path
     */
    tradePath() {
        const network = this._uniswapPairFactoryContext.ethersProvider.network();
        return trade_path_1.getTradePath(network.chainId, this.fromToken, this.toToken);
    }
    /**
     * Generates the trade datetime unix time
     */
    generateTradeDeadlineUnixTime() {
        const now = new Date();
        const expiryDate = new Date(now.getTime() +
            this._uniswapPairFactoryContext.settings.deadlineMinutes * 60000);
        return (expiryDate.getTime() / 1e3) | 0;
    }
    /**
     * Watch trade price move automatically emitting the stream if it changes
     * @param tradeContext The old trade context aka the current one
     */
    watchTradePrice(tradeContext) {
        return __awaiter(this, void 0, void 0, function* () {
            this._quoteChangeTimeout = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                if (this._quoteChanged$.observers.length > 0) {
                    const trade = yield this.executeTradePath(new bignumber_js_1.default(tradeContext.baseConvertRequest));
                    if (!new bignumber_js_1.default(trade.expectedConvertQuote).eq(tradeContext.expectedConvertQuote) ||
                        trade.routeText !== tradeContext.routeText) {
                        this._quoteChanged$.next(trade);
                        this.watchTradePrice(trade);
                        return;
                    }
                    // it has expired send another one to them
                    if (tradeContext.tradeExpires > this.generateTradeDeadlineUnixTime()) {
                        this._quoteChanged$.next(trade);
                        this.watchTradePrice(trade);
                        return;
                    }
                    this.watchTradePrice(tradeContext);
                }
                else {
                    this.watchTradePrice(tradeContext);
                }
                // maybe make config???
                // query new prices every 10 seconds
            }), 10000);
        });
    }
}
exports.UniswapPairFactory = UniswapPairFactory;
