"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensFactory = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ethereum_multicall_1 = require("ethereum-multicall");
const ethers_1 = require("ethers");
const contract_context_1 = require("../../common/contract-context");
const error_codes_1 = require("../../common/errors/error-codes");
const uniswap_error_1 = require("../../common/errors/uniswap-error");
const uniswap_version_1 = require("../../enums/uniswap-version");
const uniswap_contract_context_v2_1 = require("../../uniswap-contract-context/uniswap-contract-context-v2");
const uniswap_contract_context_v3_1 = require("../../uniswap-contract-context/uniswap-contract-context-v3");
class TokensFactory {
    constructor(_ethersProvider) {
        this._ethersProvider = _ethersProvider;
        this._multicall = new ethereum_multicall_1.Multicall({
            ethersProvider: this._ethersProvider.provider,
            tryAggregate: true,
        });
    }
    /**
     * Get the tokens details
     */
    getTokens(tokenContractAddresses) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const SYMBOL = 0;
                const DECIMALS = 1;
                const NAME = 2;
                const contractCallContexts = [];
                for (let i = 0; i < tokenContractAddresses.length; i++) {
                    const contractCallContext = {
                        reference: `token${i}`,
                        contractAddress: ethers_1.ethers.utils.getAddress(tokenContractAddresses[i]),
                        abi: contract_context_1.ContractContext.erc20Abi,
                        calls: [
                            {
                                reference: 'symbol',
                                methodName: 'symbol',
                                methodParameters: [],
                            },
                            {
                                reference: 'decimals',
                                methodName: 'decimals',
                                methodParameters: [],
                            },
                            {
                                reference: 'name',
                                methodName: 'name',
                                methodParameters: [],
                            },
                        ],
                    };
                    contractCallContexts.push(contractCallContext);
                }
                const contractCallResults = yield this._multicall.call(contractCallContexts);
                const tokens = [];
                for (const result in contractCallResults.results) {
                    const tokenInfo = contractCallResults.results[result];
                    tokens.push({
                        chainId: this._ethersProvider.network().chainId,
                        contractAddress: tokenInfo.originalContractCallContext.contractAddress,
                        symbol: tokenInfo.callsReturnContext[SYMBOL].returnValues[0],
                        decimals: tokenInfo.callsReturnContext[DECIMALS].returnValues[0],
                        name: tokenInfo.callsReturnContext[NAME].returnValues[0],
                    });
                }
                return tokens;
            }
            catch (error) {
                throw new uniswap_error_1.UniswapError('invalid from or to contract tokens', error_codes_1.ErrorCodes.invalidFromOrToContractToken);
            }
        });
    }
    /**
     * Get allowance and balance for many contracts
     * @param uniswapVersion The uniswap version
     * @param ethereumAddress The ethereum address
     * @param tokenContractAddresses The token contract addresses
     * @param format If you want it to format it for you to the correct decimal place
     */
    getAllowanceAndBalanceOfForContracts(uniswapVersion, ethereumAddress, tokenContractAddresses, format = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const ALLOWANCE = 0;
            const BALANCEOF = 1;
            const DECIMALS = 2;
            const SYMBOL = 3;
            const NAME = 4;
            const contractCallContexts = [];
            for (let i = 0; i < tokenContractAddresses.length; i++) {
                const contractCallContext = {
                    reference: `allowance-and-balance-of-${i}`,
                    contractAddress: ethers_1.ethers.utils.getAddress(tokenContractAddresses[i]),
                    abi: contract_context_1.ContractContext.erc20Abi,
                    calls: [
                        {
                            reference: 'allowance',
                            methodName: 'allowance',
                            methodParameters: [
                                ethereumAddress,
                                uniswapVersion === uniswap_version_1.UniswapVersion.v2
                                    ? uniswap_contract_context_v2_1.UniswapContractContextV2.routerAddress
                                    : uniswap_contract_context_v3_1.UniswapContractContextV3.routerAddress,
                            ],
                        },
                        {
                            reference: 'balanceOf',
                            methodName: 'balanceOf',
                            methodParameters: [ethereumAddress],
                        },
                        {
                            reference: 'decimals',
                            methodName: 'decimals',
                            methodParameters: [],
                        },
                        {
                            reference: 'symbol',
                            methodName: 'symbol',
                            methodParameters: [],
                        },
                        {
                            reference: 'name',
                            methodName: 'name',
                            methodParameters: [],
                        },
                    ],
                };
                contractCallContexts.push(contractCallContext);
            }
            const contractCallResults = yield this._multicall.call(contractCallContexts);
            const results = [];
            for (const result in contractCallResults.results) {
                const resultInfo = contractCallResults.results[result];
                if (!format) {
                    results.push({
                        allowanceAndBalanceOf: {
                            allowance: ethers_1.BigNumber.from(resultInfo.callsReturnContext[ALLOWANCE].returnValues[0]).toHexString(),
                            balanceOf: ethers_1.BigNumber.from(resultInfo.callsReturnContext[BALANCEOF].returnValues[0]).toHexString(),
                        },
                        token: {
                            chainId: this._ethersProvider.network().chainId,
                            contractAddress: resultInfo.originalContractCallContext.contractAddress,
                            symbol: resultInfo.callsReturnContext[SYMBOL].returnValues[0],
                            decimals: resultInfo.callsReturnContext[DECIMALS].returnValues[0],
                            name: resultInfo.callsReturnContext[NAME].returnValues[0],
                        },
                    });
                }
                else {
                    results.push({
                        allowanceAndBalanceOf: {
                            allowance: new bignumber_js_1.default(ethers_1.BigNumber.from(resultInfo.callsReturnContext[ALLOWANCE].returnValues[0]).toHexString())
                                .shiftedBy(resultInfo.callsReturnContext[DECIMALS].returnValues[0] * -1)
                                .toFixed(),
                            balanceOf: new bignumber_js_1.default(ethers_1.BigNumber.from(resultInfo.callsReturnContext[BALANCEOF].returnValues[0]).toHexString())
                                .shiftedBy(resultInfo.callsReturnContext[DECIMALS].returnValues[0] * -1)
                                .toFixed(),
                        },
                        token: {
                            chainId: this._ethersProvider.network().chainId,
                            contractAddress: resultInfo.originalContractCallContext.contractAddress,
                            symbol: resultInfo.callsReturnContext[SYMBOL].returnValues[0],
                            decimals: resultInfo.callsReturnContext[DECIMALS].returnValues[0],
                            name: resultInfo.callsReturnContext[NAME].returnValues[0],
                        },
                    });
                }
            }
            return results;
        });
    }
}
exports.TokensFactory = TokensFactory;
